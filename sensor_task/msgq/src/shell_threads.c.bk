/* shell_threads.c : independent periodic workers → msgq → 20s batched file writes
 *	- Each worker samples on its own interval and enqueues a preformatted line
 *	- Logger thread buffers queue items in RAM and appends them to LittleFS every 20 s
 *	- No worker/chain semaphores; threads are independent
 *	- Tickless-friendly sleeps (system idles between activity)
 */

#include "shell_threads.h"
#include <zephyr/kernel.h>
#include <zephyr/fs/fs.h>
#include <zephyr/fs/littlefs.h>
#include <zephyr/storage/flash_map.h>
#include <zephyr/logging/log.h>
#include <zephyr/shell/shell.h>
#include <string.h>
#include <stdbool.h>

LOG_MODULE_REGISTER(shell_threads);

/* ------------ config ------------ */
#define SENSOR_PATH			"/lfs/sensor.txt"

/* per-sensor sampling periods (tune as you like) */
#define HT_PERIOD_MS			2000		/* 2 s */
#define PRESS_PERIOD_MS			5000		/* 5 s */
#define IMU_PERIOD_MS			1000		/* 1 s */

/* batched file write period */
#define FLUSH_PERIOD_MS			20000		/* 20 s */

/* message queue depth and stash capacity */
#define LOG_MSGQ_DEPTH			64		/* queueed records before logger */
#define LOG_STASH_CAP			256		/* batched records per flush */

/* ------------ threads & stacks ------------ */
static struct k_thread		ht_thread_data, press_thread_data, imu_thread_data, log_thread_data;
static K_THREAD_STACK_DEFINE(ht_stack,	 2048);
static K_THREAD_STACK_DEFINE(press_stack, 2048);
static K_THREAD_STACK_DEFINE(imu_stack,	 2048);
static K_THREAD_STACK_DEFINE(log_stack,	 3072);

static k_tid_t			ht_tid, press_tid, imu_tid, log_tid;

/* ------------ msg queue payload ------------ */
struct log_item
{
	char	buf[256];		/* one preformatted line (CRLF included) */
	uint16_t len;			/* actual length to write */
	uint16_t _pad;			/* keep 4B alignment (msgq align=4) */
};

/* single producer/consumer hub: all workers → this queue → logger */
K_MSGQ_DEFINE(log_q, sizeof(struct log_item), LOG_MSGQ_DEPTH, 4);

/* ------------ helpers ------------ */
static inline void ts_now(uint32_t *sec, uint32_t *mms)
{
	uint64_t ms = k_uptime_get();
	*sec = (uint32_t)(ms / 1000U);
	*mms = (uint32_t)(ms % 1000U);
}

/* worker-safe enqueue helper (blocks if queue is full → back-pressure) */
static inline void enqueue_line(const char *line, size_t n)
{
	if (n == 0 || n > sizeof(((struct log_item *)0)->buf)) {
		return;
	}
	struct log_item it;
	it.len = (uint16_t)n;
	memcpy(it.buf, line, n);
	k_msgq_put(&log_q, &it, K_FOREVER);
}

/* ------------ sensor workers (independent, no FS, no sems) ------------ */
/* NOTE: These use your existing *_get_string() helpers and reformat lines.	*/
/* If you own those drivers, prefer numeric getters to avoid sscanf/format cost. */

void ht_thread(void *a, void *b, void *c)
{
	char	inbuf[128];
	char	out[256];

	int64_t next = k_uptime_get();

	for (;;)
	{
		next += HT_PERIOD_MS;

		/* read once; best-effort parse */
		bool	ok = false;
		float	t = 0.0f, h = 0.0f;

		if (hum_temp_sensor_get_string(inbuf, sizeof(inbuf)) > 0) {
			/* expects: "Temperature: %f C, Humidity: %f %%" */
			if (sscanf(inbuf, "Temperature: %f C, Humidity: %f %%", &t, &h) == 2) {
				ok = true;
			}
		}

		uint32_t sec, mms; ts_now(&sec, &mms);
		size_t n = snprintk(out, sizeof(out),
			"[%lu.%03lu] SRC=HT  OK=%c  T=%.2fC  H=%.2f%%\r\n",
			sec, mms, ok ? 'Y' : 'N', t, h);
		enqueue_line(out, n);

		/* sleep to absolute boundary */
		int64_t now = k_uptime_get();
		int64_t slp = next - now;
		if (slp < 1) slp = 1;
		k_msleep((int)slp);
	}
}

void press_thread(void *a, void *b, void *c)
{
	char	inbuf[128];
	char	out[256];

	int64_t next = k_uptime_get();

	for (;;)
	{
		next += PRESS_PERIOD_MS;

		bool	ok = false;
		float	p = 0.0f;
		if (pressure_sensor_get_string(inbuf, sizeof(inbuf)) > 0) {
			/* expects: "Pressure: %f" (kPa) */
			if (sscanf(inbuf, "Pressure: %f", &p) == 1) {
				ok = true;
			}
		}

		uint32_t sec, mms; ts_now(&sec, &mms);
		size_t n = snprintk(out, sizeof(out),
			"[%lu.%03lu] SRC=PRES OK=%c  P=%.3fkPa\r\n",
			sec, mms, ok ? 'Y' : 'N', p);
		enqueue_line(out, n);

		int64_t now = k_uptime_get();
		int64_t slp = next - now;
		if (slp < 1) slp = 1;
		k_msleep((int)slp);
	}
}

void imu_thread(void *a, void *b, void *c)
{
	char	inbuf[192];
	char	out[256];

	int64_t next = k_uptime_get();

	for (;;)
	{
		next += IMU_PERIOD_MS;

		bool	ok = false;
		float	ax=0, ay=0, az=0, gx=0, gy=0, gz=0;
		if (imu_sensor_get_string(inbuf, sizeof(inbuf)) > 0) {
			/* expects: "Accel: %f, %f, %f | Gyro: %f, %f, %f" */
			if (sscanf(inbuf, "Accel: %f, %f, %f | Gyro: %f, %f, %f", &ax,&ay,&az,&gx,&gy,&gz) == 6) {
				ok = true;
			}
		}

		uint32_t sec, mms; ts_now(&sec, &mms);
		size_t n = snprintk(out, sizeof(out),
			"[%lu.%03lu] SRC=IMU OK=%c  A=(%.3f,%.3f,%.3f)  G=(%.3f,%.3f,%.3f)\r\n",
			sec, mms, ok ? 'Y' : 'N', ax, ay, az, gx, gy, gz);
		enqueue_line(out, n);

		int64_t now = k_uptime_get();
		int64_t slp = next - now;
		if (slp < 1) slp = 1;
		k_msleep((int)slp);
	}
}

/* ------------ logger (drains queue; flushes every 20 s) ------------ */
void logger_thread(void *a, void *b, void *c)
{
	struct fs_file_t	file;

	/* stash collected lines between flushes */
	struct log_item		stash[LOG_STASH_CAP];
	uint16_t		count = 0;

	/* align first flush to the next 20 s boundary for neat timestamps */
	int64_t now = k_uptime_get();
	int64_t next_flush = now - (now % FLUSH_PERIOD_MS) + FLUSH_PERIOD_MS;

	for (;;)
	{
		/* time until next flush; wait for data or timeout to flush */
		now = k_uptime_get();
		int32_t to_ms = (int32_t)(next_flush - now);
		if (to_ms < 1) to_ms = 1;

		struct log_item it;
		int rc = k_msgq_get(&log_q, &it, K_MSEC(to_ms));
		if (rc == 0) {
			/* stash it (drop-oldest if stash is full) */
			if (count < LOG_STASH_CAP) {
				stash[count++] = it;
			} else {
				/* optional: drop-oldest policy */
				memmove(&stash[0], &stash[1], (LOG_STASH_CAP - 1) * sizeof(stash[0]));
				stash[LOG_STASH_CAP - 1] = it;
			}
		}

		now = k_uptime_get();
		if (now >= next_flush) {
			/* flush everything in one open/write/close */
			if (count > 0) {
				fs_file_t_init(&file);
				if (fs_open(&file, SENSOR_PATH, FS_O_CREATE | FS_O_WRITE | FS_O_APPEND) == 0) {
					for (uint16_t i = 0; i < count; ++i) {
						(void)fs_write(&file, stash[i].buf, stash[i].len);
					}
					(void)fs_close(&file);
				}
				count = 0;
			}
			next_flush += FLUSH_PERIOD_MS;
		}
	}
}

/* ------------ shell commands ------------ */
static int cmd_start_sensor(const struct shell *sh, size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	/* clean msgq state on fresh start */
	k_msgq_purge(&log_q);

	if (!ht_tid) {
		ht_tid = k_thread_create(&ht_thread_data, ht_stack,
			K_THREAD_STACK_SIZEOF(ht_stack),
			ht_thread, NULL, NULL, NULL,
			5, 0, K_NO_WAIT);
		shell_print(sh, "HT worker started (period=%d ms).", HT_PERIOD_MS);
	}
	if (!press_tid) {
		press_tid = k_thread_create(&press_thread_data, press_stack,
			K_THREAD_STACK_SIZEOF(press_stack),
			press_thread, NULL, NULL, NULL,
			5, 0, K_NO_WAIT);
		shell_print(sh, "PRESS worker started (period=%d ms).", PRESS_PERIOD_MS);
	}
	if (!imu_tid) {
		imu_tid = k_thread_create(&imu_thread_data, imu_stack,
			K_THREAD_STACK_SIZEOF(imu_stack),
			imu_thread, NULL, NULL, NULL,
			5, 0, K_NO_WAIT);
		shell_print(sh, "IMU worker started (period=%d ms).", IMU_PERIOD_MS);
	}
	if (!log_tid) {
		log_tid = k_thread_create(&log_thread_data, log_stack,
			K_THREAD_STACK_SIZEOF(log_stack),
			logger_thread, NULL, NULL, NULL,
			4, 0, K_NO_WAIT);
		shell_print(sh, "Logger started (flush period=%d ms).", FLUSH_PERIOD_MS);
	}

	return 0;
}

static int cmd_stop_sensors(const struct shell *sh, size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	if (ht_tid)    { k_thread_abort(ht_tid);    ht_tid    = NULL; shell_print(sh, "HT worker stopped."); }
	if (press_tid) { k_thread_abort(press_tid); press_tid = NULL; shell_print(sh, "PRESS worker stopped."); }
	if (imu_tid)   { k_thread_abort(imu_tid);   imu_tid   = NULL; shell_print(sh, "IMU worker stopped."); }
	if (log_tid)   { k_thread_abort(log_tid);   log_tid   = NULL; shell_print(sh, "Logger stopped."); }

	k_msgq_purge(&log_q);

	return 0;
}

static int cmd_clear_logs(const struct shell *shell, size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	int ret = fs_unlink(SENSOR_PATH);
	if (ret < 0 && ret != -ENOENT) {
		shell_fprintf(shell, SHELL_ERROR, "Failed to remove %s (%d)\n", SENSOR_PATH, ret);
		return ret;
	}
	shell_fprintf(shell, SHELL_NORMAL, "Log cleared: %s\n", SENSOR_PATH);
	return 0;
}

/* ------------ shell registration ------------ */
SHELL_STATIC_SUBCMD_SET_CREATE(sub_sensors,
	SHELL_CMD(start_sensors,	NULL, "Start periodic workers + 20s batched logger",	cmd_start_sensor),
	SHELL_CMD(stop_sensors,		NULL, "Stop all workers and logger",			cmd_stop_sensors),
	SHELL_CMD(clear_logs,		NULL, "Delete the log file",				cmd_clear_logs),
	SHELL_SUBCMD_SET_END
);
SHELL_CMD_REGISTER(sensors, &sub_sensors, "Sensor logging commands", NULL);

